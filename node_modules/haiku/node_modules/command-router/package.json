{
  "name": "command-router",
  "version": "0.0.5",
  "description": "A simple CLI router apps with multiple commands",
  "keywords": [
    "cli",
    "command",
    "line",
    "args",
    "arguments",
    "option",
    "command"
  ],
  "author": {
    "name": "Jason Campbell",
    "email": "jason@js.la",
    "url": "http://js.la"
  },
  "main": "index.js",
  "dependencies": {
    "nopt": "2.1.1",
    "routes": "0.1.1"
  },
  "devDependencies": {
    "mocha": "1.8.2"
  },
  "scripts": {
    "test": "mocha test/test-*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jxson/command-router.git"
  },
  "engines": {
    "node": "> 0.6.6"
  },
  "license": "MIT",
  "readme": "\n# command-router [![Build Status](https://travis-ci.org/jxson/command-router.png?branch=master)](https://travis-ci.org/jxson/command-router)\n\nWriting simple, composable modules makes it easy to have your applications functionality available in multiple contexts. `command-router` aims to help you expose that functionality by providing a simple way to define a CLI with multiple actions (like `git`).\n\n`command-router` provides:\n\n* A simple way to declare routing definitions using normal functions.\n* A clean way to define options, their aliases, and default values\n* Coming Soon: Tab completion\n\nIf your app only has one command (like `curl` for instance) you should use a [different module]][optimist] instead of this one.\n\n# Install\n\nWith [npm][npm] do:\n\n    npm install command-router\n\n# Example\n\nIn your bin or JS file:\n\n    var cli = require('command-router')\n\n    // Options are optional, and basic boolean options that default to\n    // false can be simply defined\n    cli.option('verbose')\n\n    // Define the --port option with an alias of -p and set an\n    // intelligent default\n    cli.option({ name: 'port'\n    , alias: 'p'\n    , default: process.env.PORT || 8080\n    , type: Number\n    })\n\n    cli.command('help', function(){\n      console.log('commands: server')\n    })\n\n    cli.command('server', function(){\n      if (cli.options.help) {\n        return console.log('Help for server the command')\n      }\n\n      // code for running server here...\n    })\n\n    // Set the whole thing in motion...\n    cli.parse(process.argv)\n\nBy default, if a route is not found `command-router` will throw unless you add add a listener for the `notfound` event (I couldn't think of a better way to handle this, if you have a better idea [let me know][issues]). This is important for instances when scripting your CLI and you need proper exit codes when piping to other utilities.\n\n    cli.on('notfound', function(action){\n      console.error('I don\\'t know how to: ' + action)\n\n      // you could even get smart and display some info about what\n      // should happen next\n\n      process.exit(1)\n    })\n\n\n# Methods\n\n    var cli = require('command-router')\n\n## cli.command(route, fn)\n\nDefine route matchers for your application using a string or regex for `route`, the `fn` function will be triggered if the `route` is matched when `cli.parse()` is called. The `fn` is called with `params` and `options` arguments which are also available directly on the cli object.\n\nThis routing style is heavily influenced by [sinatra][sinatra] and relies on the wonderful [routes][routes] module, for more details on how to define routes check it's [documentation][routes].\n\n### Examples\n\n    // simple stringed route\n    cli.command('speak dog', function(){\n      console.log('woof.')\n    })\n\n    // name params\n    cli.command('speak :animal', function(){\n      console.log(cli.params.animal)\n    })\n\n    // splats!\n    cli.command('speak *', function(){\n      console.log(cli.params.splat)\n    })\n\n    // regex, don't cut your self...\n    cli.command(/speak (.*)$/, function(){\n      console.log(cli.params.splat)\n    })\n\n## cli.option(params)\n\nDefine available options, their aliases, and default values.\n\n### params\n\n* `name`: The name of the option that will map to a command line\n* `alias`: Allows a shorthand to be defined.\n* `type`: Define the type for this flag. **Defaults to `Boolean`**\n* `default`: The default value for the option being defined. **Defaults to `false`**\n\n#### params.type\n\n[nopt][nopt] is used for parsing the options internally. `params.type` will need to be one of the types defined in `nopt.typeDefs`:\n\n* String: A normal string.  No parsing is done.\n* path: A file system path.  Gets resolved against cwd if not absolute.\n* url: A url.  If it doesn't parse, it isn't accepted.\n* Number: Must be numeric.\n* Date: Must parse as a date. If it does, and `Date` is one of the options,\n  then it will return a Date object, not a string.\n* Boolean: Must be either `true` or `false`.  If an option is a boolean,\n  then it does not need a value, and its presence will imply `true` as\n  the value.  To negate boolean flags, do `--no-whatever` or `--whatever\n  false`\n* NaN: Means that the option is strictly not allowed.  Any value will\n  fail.\n* Stream: An object matching the \"Stream\" class in node.  Valuable\n  for use when validating programmatically.  (npm uses this to let you\n  supply any WriteStream on the `outfd` and `logfd` config options.)\n* Array: If `Array` is specified as one of the types, then the value\n  will be parsed as a list of options.  This means that multiple values\n  can be specified, and that the value will always be an array.\n\nSee the [nopt][nopt] documentation for more details.\n\n### Examples\n\nIf the `params` object is missing keys for `type` and `default` the option will be defined as a `Boolean` type defaulting to `false` without an alias:\n\n    cli.option({ name: 'verbose' })\n\n    // Is the equivalent to:\n\n    cli.option({ name: 'verbose'\n    , type: Boolean\n    , default: false\n    })\n\n    // And can be simplifed to\n\n    cli.option('verbose')\n\nTo set an option for something like a `path` to a config file:\n\n    var path = require('path')\n\n    cli.option({ name: 'config'\n    , alias: 'c'\n    , default: '.haiku/config.js'\n    , type: path\n    })\n\n## cli.parse(argv)\n\nParses the `argv` array and triggers the appropriate route.\n\n# Built on the backs of better developers\n\nThis project is really just a simple API which wraps several other excellent libraries:\n\n* [nopt][nopt]\n* [routes][routes]\n\n# License\n\nMIT\n\n[npm]: http://npmjs.org\n[optimist]: https://npmjs.org/package/optimist\n[issues]: https://github.com/jxson/command-router/issues\n[routes]: https://npmjs.org/package/routes\n[sinatra]: http://www.sinatrarb.com\n[nopt]: https://npmjs.org/package/nopt\n",
  "readmeFilename": "README.md",
  "_id": "command-router@0.0.5",
  "dist": {
    "shasum": "7238a2ec822f6af307d2c8904d2820ad043d9d55"
  },
  "_from": "command-router@0.0.5",
  "_resolved": "https://registry.npmjs.org/command-router/-/command-router-0.0.5.tgz"
}
